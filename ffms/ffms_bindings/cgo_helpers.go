// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Wed, 02 Jul 2025 23:31:51 UTC.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package ffms_bindings

/*
#cgo pkg-config: ffms2
#include "ffms.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocErrorInfoMemory allocates memory for type C.FFMS_ErrorInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocErrorInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfErrorInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfErrorInfoValue = unsafe.Sizeof([1]C.FFMS_ErrorInfo{})

// copyPCharBytes copies the data from Go slice as *C.char.
func copyPCharBytes(slice *sliceHeader) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfCharValue) * slice.Len,
		Cap:  int(sizeOfCharValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.char)(mem0), allocs
}

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

// allocCharMemory allocates memory for type C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCharValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCharValue = unsafe.Sizeof([1]C.char{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ErrorInfo) Ref() *C.FFMS_ErrorInfo {
	if x == nil {
		return nil
	}
	return x.ref43ef05fa
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ErrorInfo) Free() {
	if x != nil && x.allocs43ef05fa != nil {
		x.allocs43ef05fa.(*cgoAllocMap).Free()
		x.ref43ef05fa = nil
	}
}

// NewErrorInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewErrorInfoRef(ref unsafe.Pointer) *ErrorInfo {
	if ref == nil {
		return nil
	}
	obj := new(ErrorInfo)
	obj.ref43ef05fa = (*C.FFMS_ErrorInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ErrorInfo) PassRef() (*C.FFMS_ErrorInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref43ef05fa != nil {
		return x.ref43ef05fa, nil
	}
	mem43ef05fa := allocErrorInfoMemory(1)
	ref43ef05fa := (*C.FFMS_ErrorInfo)(mem43ef05fa)
	allocs43ef05fa := new(cgoAllocMap)
	allocs43ef05fa.Add(mem43ef05fa)

	var cErrorType_allocs *cgoAllocMap
	ref43ef05fa.ErrorType, cErrorType_allocs = (C.int)(x.ErrorType), cgoAllocsUnknown
	allocs43ef05fa.Borrow(cErrorType_allocs)

	var cSubType_allocs *cgoAllocMap
	ref43ef05fa.SubType, cSubType_allocs = (C.int)(x.SubType), cgoAllocsUnknown
	allocs43ef05fa.Borrow(cSubType_allocs)

	var cBufferSize_allocs *cgoAllocMap
	ref43ef05fa.BufferSize, cBufferSize_allocs = (C.int)(x.BufferSize), cgoAllocsUnknown
	allocs43ef05fa.Borrow(cBufferSize_allocs)

	var cBuffer_allocs *cgoAllocMap
	ref43ef05fa.Buffer, cBuffer_allocs = copyPCharBytes((*sliceHeader)(unsafe.Pointer(&x.Buffer)))
	allocs43ef05fa.Borrow(cBuffer_allocs)

	x.ref43ef05fa = ref43ef05fa
	x.allocs43ef05fa = allocs43ef05fa
	return ref43ef05fa, allocs43ef05fa

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ErrorInfo) PassValue() (C.FFMS_ErrorInfo, *cgoAllocMap) {
	if x.ref43ef05fa != nil {
		return *x.ref43ef05fa, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ErrorInfo) Deref() {
	if x.ref43ef05fa == nil {
		return
	}
	x.ErrorType = (int32)(x.ref43ef05fa.ErrorType)
	x.SubType = (int32)(x.ref43ef05fa.SubType)
	x.BufferSize = (int32)(x.ref43ef05fa.BufferSize)
	hxfc4425b := (*sliceHeader)(unsafe.Pointer(&x.Buffer))
	hxfc4425b.Data = unsafe.Pointer(x.ref43ef05fa.Buffer)
	hxfc4425b.Cap = 0x7fffffff
	// hxfc4425b.Len = ? x.Buffer x.ref43ef05fa.Buffer

}

// Ref returns a reference to C object as it is.
func (x *VideoSource) Ref() *C.FFMS_VideoSource {
	if x == nil {
		return nil
	}
	return (*C.FFMS_VideoSource)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *VideoSource) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewVideoSourceRef converts the C object reference into a raw struct reference without wrapping.
func NewVideoSourceRef(ref unsafe.Pointer) *VideoSource {
	return (*VideoSource)(ref)
}

// NewVideoSource allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewVideoSource() *VideoSource {
	return (*VideoSource)(allocVideoSourceMemory(1))
}

// allocVideoSourceMemory allocates memory for type C.FFMS_VideoSource in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVideoSourceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVideoSourceValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfVideoSourceValue = unsafe.Sizeof([1]C.FFMS_VideoSource{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *VideoSource) PassRef() *C.FFMS_VideoSource {
	if x == nil {
		x = (*VideoSource)(allocVideoSourceMemory(1))
	}
	return (*C.FFMS_VideoSource)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *AudioSource) Ref() *C.FFMS_AudioSource {
	if x == nil {
		return nil
	}
	return (*C.FFMS_AudioSource)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *AudioSource) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewAudioSourceRef converts the C object reference into a raw struct reference without wrapping.
func NewAudioSourceRef(ref unsafe.Pointer) *AudioSource {
	return (*AudioSource)(ref)
}

// NewAudioSource allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewAudioSource() *AudioSource {
	return (*AudioSource)(allocAudioSourceMemory(1))
}

// allocAudioSourceMemory allocates memory for type C.FFMS_AudioSource in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAudioSourceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAudioSourceValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAudioSourceValue = unsafe.Sizeof([1]C.FFMS_AudioSource{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *AudioSource) PassRef() *C.FFMS_AudioSource {
	if x == nil {
		x = (*AudioSource)(allocAudioSourceMemory(1))
	}
	return (*C.FFMS_AudioSource)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Indexer) Ref() *C.FFMS_Indexer {
	if x == nil {
		return nil
	}
	return (*C.FFMS_Indexer)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Indexer) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewIndexerRef converts the C object reference into a raw struct reference without wrapping.
func NewIndexerRef(ref unsafe.Pointer) *Indexer {
	return (*Indexer)(ref)
}

// NewIndexer allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewIndexer() *Indexer {
	return (*Indexer)(allocIndexerMemory(1))
}

// allocIndexerMemory allocates memory for type C.FFMS_Indexer in C.
// The caller is responsible for freeing the this memory via C.free.
func allocIndexerMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfIndexerValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfIndexerValue = unsafe.Sizeof([1]C.FFMS_Indexer{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Indexer) PassRef() *C.FFMS_Indexer {
	if x == nil {
		x = (*Indexer)(allocIndexerMemory(1))
	}
	return (*C.FFMS_Indexer)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Index) Ref() *C.FFMS_Index {
	if x == nil {
		return nil
	}
	return (*C.FFMS_Index)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Index) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewIndexRef converts the C object reference into a raw struct reference without wrapping.
func NewIndexRef(ref unsafe.Pointer) *Index {
	return (*Index)(ref)
}

// NewIndex allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewIndex() *Index {
	return (*Index)(allocIndexMemory(1))
}

// allocIndexMemory allocates memory for type C.FFMS_Index in C.
// The caller is responsible for freeing the this memory via C.free.
func allocIndexMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfIndexValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfIndexValue = unsafe.Sizeof([1]C.FFMS_Index{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Index) PassRef() *C.FFMS_Index {
	if x == nil {
		x = (*Index)(allocIndexMemory(1))
	}
	return (*C.FFMS_Index)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Track) Ref() *C.FFMS_Track {
	if x == nil {
		return nil
	}
	return (*C.FFMS_Track)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Track) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTrackRef converts the C object reference into a raw struct reference without wrapping.
func NewTrackRef(ref unsafe.Pointer) *Track {
	return (*Track)(ref)
}

// NewTrack allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTrack() *Track {
	return (*Track)(allocTrackMemory(1))
}

// allocTrackMemory allocates memory for type C.FFMS_Track in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTrackMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTrackValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTrackValue = unsafe.Sizeof([1]C.FFMS_Track{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Track) PassRef() *C.FFMS_Track {
	if x == nil {
		x = (*Track)(allocTrackMemory(1))
	}
	return (*C.FFMS_Track)(unsafe.Pointer(x))
}

// allocResampleOptionsMemory allocates memory for type C.FFMS_ResampleOptions in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResampleOptionsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResampleOptionsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResampleOptionsValue = unsafe.Sizeof([1]C.FFMS_ResampleOptions{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResampleOptions) Ref() *C.FFMS_ResampleOptions {
	if x == nil {
		return nil
	}
	return x.ref2fdbecca
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResampleOptions) Free() {
	if x != nil && x.allocs2fdbecca != nil {
		x.allocs2fdbecca.(*cgoAllocMap).Free()
		x.ref2fdbecca = nil
	}
}

// NewResampleOptionsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResampleOptionsRef(ref unsafe.Pointer) *ResampleOptions {
	if ref == nil {
		return nil
	}
	obj := new(ResampleOptions)
	obj.ref2fdbecca = (*C.FFMS_ResampleOptions)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResampleOptions) PassRef() (*C.FFMS_ResampleOptions, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2fdbecca != nil {
		return x.ref2fdbecca, nil
	}
	mem2fdbecca := allocResampleOptionsMemory(1)
	ref2fdbecca := (*C.FFMS_ResampleOptions)(mem2fdbecca)
	allocs2fdbecca := new(cgoAllocMap)
	allocs2fdbecca.Add(mem2fdbecca)

	var cChannelLayout_allocs *cgoAllocMap
	ref2fdbecca.ChannelLayout, cChannelLayout_allocs = (C.int64_t)(x.ChannelLayout), cgoAllocsUnknown
	allocs2fdbecca.Borrow(cChannelLayout_allocs)

	var cSampleFormat_allocs *cgoAllocMap
	ref2fdbecca.SampleFormat, cSampleFormat_allocs = (C.FFMS_SampleFormat)(x.SampleFormat), cgoAllocsUnknown
	allocs2fdbecca.Borrow(cSampleFormat_allocs)

	var cSampleRate_allocs *cgoAllocMap
	ref2fdbecca.SampleRate, cSampleRate_allocs = (C.int)(x.SampleRate), cgoAllocsUnknown
	allocs2fdbecca.Borrow(cSampleRate_allocs)

	var cMixingCoefficientType_allocs *cgoAllocMap
	ref2fdbecca.MixingCoefficientType, cMixingCoefficientType_allocs = (C.FFMS_MixingCoefficientType)(x.MixingCoefficientType), cgoAllocsUnknown
	allocs2fdbecca.Borrow(cMixingCoefficientType_allocs)

	var cCenterMixLevel_allocs *cgoAllocMap
	ref2fdbecca.CenterMixLevel, cCenterMixLevel_allocs = (C.double)(x.CenterMixLevel), cgoAllocsUnknown
	allocs2fdbecca.Borrow(cCenterMixLevel_allocs)

	var cSurroundMixLevel_allocs *cgoAllocMap
	ref2fdbecca.SurroundMixLevel, cSurroundMixLevel_allocs = (C.double)(x.SurroundMixLevel), cgoAllocsUnknown
	allocs2fdbecca.Borrow(cSurroundMixLevel_allocs)

	var cLFEMixLevel_allocs *cgoAllocMap
	ref2fdbecca.LFEMixLevel, cLFEMixLevel_allocs = (C.double)(x.LFEMixLevel), cgoAllocsUnknown
	allocs2fdbecca.Borrow(cLFEMixLevel_allocs)

	var cNormalize_allocs *cgoAllocMap
	ref2fdbecca.Normalize, cNormalize_allocs = (C.int)(x.Normalize), cgoAllocsUnknown
	allocs2fdbecca.Borrow(cNormalize_allocs)

	var cForceResample_allocs *cgoAllocMap
	ref2fdbecca.ForceResample, cForceResample_allocs = (C.int)(x.ForceResample), cgoAllocsUnknown
	allocs2fdbecca.Borrow(cForceResample_allocs)

	var cResampleFilterSize_allocs *cgoAllocMap
	ref2fdbecca.ResampleFilterSize, cResampleFilterSize_allocs = (C.int)(x.ResampleFilterSize), cgoAllocsUnknown
	allocs2fdbecca.Borrow(cResampleFilterSize_allocs)

	var cResamplePhaseShift_allocs *cgoAllocMap
	ref2fdbecca.ResamplePhaseShift, cResamplePhaseShift_allocs = (C.int)(x.ResamplePhaseShift), cgoAllocsUnknown
	allocs2fdbecca.Borrow(cResamplePhaseShift_allocs)

	var cLinearInterpolation_allocs *cgoAllocMap
	ref2fdbecca.LinearInterpolation, cLinearInterpolation_allocs = (C.int)(x.LinearInterpolation), cgoAllocsUnknown
	allocs2fdbecca.Borrow(cLinearInterpolation_allocs)

	var cCutoffFrequencyRatio_allocs *cgoAllocMap
	ref2fdbecca.CutoffFrequencyRatio, cCutoffFrequencyRatio_allocs = (C.double)(x.CutoffFrequencyRatio), cgoAllocsUnknown
	allocs2fdbecca.Borrow(cCutoffFrequencyRatio_allocs)

	var cMatrixedStereoEncoding_allocs *cgoAllocMap
	ref2fdbecca.MatrixedStereoEncoding, cMatrixedStereoEncoding_allocs = (C.FFMS_MatrixEncoding)(x.MatrixedStereoEncoding), cgoAllocsUnknown
	allocs2fdbecca.Borrow(cMatrixedStereoEncoding_allocs)

	var cFilterType_allocs *cgoAllocMap
	ref2fdbecca.FilterType, cFilterType_allocs = (C.FFMS_ResampleFilterType)(x.FilterType), cgoAllocsUnknown
	allocs2fdbecca.Borrow(cFilterType_allocs)

	var cKaiserBeta_allocs *cgoAllocMap
	ref2fdbecca.KaiserBeta, cKaiserBeta_allocs = (C.int)(x.KaiserBeta), cgoAllocsUnknown
	allocs2fdbecca.Borrow(cKaiserBeta_allocs)

	var cDitherMethod_allocs *cgoAllocMap
	ref2fdbecca.DitherMethod, cDitherMethod_allocs = (C.FFMS_AudioDitherMethod)(x.DitherMethod), cgoAllocsUnknown
	allocs2fdbecca.Borrow(cDitherMethod_allocs)

	x.ref2fdbecca = ref2fdbecca
	x.allocs2fdbecca = allocs2fdbecca
	return ref2fdbecca, allocs2fdbecca

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResampleOptions) PassValue() (C.FFMS_ResampleOptions, *cgoAllocMap) {
	if x.ref2fdbecca != nil {
		return *x.ref2fdbecca, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResampleOptions) Deref() {
	if x.ref2fdbecca == nil {
		return
	}
	x.ChannelLayout = (int64)(x.ref2fdbecca.ChannelLayout)
	x.SampleFormat = (SampleFormat)(x.ref2fdbecca.SampleFormat)
	x.SampleRate = (int32)(x.ref2fdbecca.SampleRate)
	x.MixingCoefficientType = (MixingCoefficientType)(x.ref2fdbecca.MixingCoefficientType)
	x.CenterMixLevel = (float64)(x.ref2fdbecca.CenterMixLevel)
	x.SurroundMixLevel = (float64)(x.ref2fdbecca.SurroundMixLevel)
	x.LFEMixLevel = (float64)(x.ref2fdbecca.LFEMixLevel)
	x.Normalize = (int32)(x.ref2fdbecca.Normalize)
	x.ForceResample = (int32)(x.ref2fdbecca.ForceResample)
	x.ResampleFilterSize = (int32)(x.ref2fdbecca.ResampleFilterSize)
	x.ResamplePhaseShift = (int32)(x.ref2fdbecca.ResamplePhaseShift)
	x.LinearInterpolation = (int32)(x.ref2fdbecca.LinearInterpolation)
	x.CutoffFrequencyRatio = (float64)(x.ref2fdbecca.CutoffFrequencyRatio)
	x.MatrixedStereoEncoding = (MatrixEncoding)(x.ref2fdbecca.MatrixedStereoEncoding)
	x.FilterType = (ResampleFilterType)(x.ref2fdbecca.FilterType)
	x.KaiserBeta = (int32)(x.ref2fdbecca.KaiserBeta)
	x.DitherMethod = (AudioDitherMethod)(x.ref2fdbecca.DitherMethod)
}

// allocFrameMemory allocates memory for type C.FFMS_Frame in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFrameMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFrameValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFrameValue = unsafe.Sizeof([1]C.FFMS_Frame{})

// copyPUint8TBytes copies the data from Go slice as *C.uint8_t.
func copyPUint8TBytes(slice *sliceHeader) (*C.uint8_t, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfUint8TValue) * slice.Len,
		Cap:  int(sizeOfUint8TValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.uint8_t)(mem0), allocs
}

// allocUint8TMemory allocates memory for type C.uint8_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUint8TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUint8TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUint8TValue = unsafe.Sizeof([1]C.uint8_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Frame) Ref() *C.FFMS_Frame {
	if x == nil {
		return nil
	}
	return x.ref32c01ffc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Frame) Free() {
	if x != nil && x.allocs32c01ffc != nil {
		x.allocs32c01ffc.(*cgoAllocMap).Free()
		x.ref32c01ffc = nil
	}
}

// NewFrameRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFrameRef(ref unsafe.Pointer) *Frame {
	if ref == nil {
		return nil
	}
	obj := new(Frame)
	obj.ref32c01ffc = (*C.FFMS_Frame)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Frame) PassRef() (*C.FFMS_Frame, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref32c01ffc != nil {
		return x.ref32c01ffc, nil
	}
	mem32c01ffc := allocFrameMemory(1)
	ref32c01ffc := (*C.FFMS_Frame)(mem32c01ffc)
	allocs32c01ffc := new(cgoAllocMap)
	allocs32c01ffc.Add(mem32c01ffc)

	var cData_allocs *cgoAllocMap
	ref32c01ffc.Data, cData_allocs = *(*[4]*C.uint8_t)(unsafe.Pointer(&x.Data)), cgoAllocsUnknown
	allocs32c01ffc.Borrow(cData_allocs)

	var cLinesize_allocs *cgoAllocMap
	ref32c01ffc.Linesize, cLinesize_allocs = *(*[4]C.int)(unsafe.Pointer(&x.Linesize)), cgoAllocsUnknown
	allocs32c01ffc.Borrow(cLinesize_allocs)

	var cEncodedWidth_allocs *cgoAllocMap
	ref32c01ffc.EncodedWidth, cEncodedWidth_allocs = (C.int)(x.EncodedWidth), cgoAllocsUnknown
	allocs32c01ffc.Borrow(cEncodedWidth_allocs)

	var cEncodedHeight_allocs *cgoAllocMap
	ref32c01ffc.EncodedHeight, cEncodedHeight_allocs = (C.int)(x.EncodedHeight), cgoAllocsUnknown
	allocs32c01ffc.Borrow(cEncodedHeight_allocs)

	var cEncodedPixelFormat_allocs *cgoAllocMap
	ref32c01ffc.EncodedPixelFormat, cEncodedPixelFormat_allocs = (C.int)(x.EncodedPixelFormat), cgoAllocsUnknown
	allocs32c01ffc.Borrow(cEncodedPixelFormat_allocs)

	var cScaledWidth_allocs *cgoAllocMap
	ref32c01ffc.ScaledWidth, cScaledWidth_allocs = (C.int)(x.ScaledWidth), cgoAllocsUnknown
	allocs32c01ffc.Borrow(cScaledWidth_allocs)

	var cScaledHeight_allocs *cgoAllocMap
	ref32c01ffc.ScaledHeight, cScaledHeight_allocs = (C.int)(x.ScaledHeight), cgoAllocsUnknown
	allocs32c01ffc.Borrow(cScaledHeight_allocs)

	var cConvertedPixelFormat_allocs *cgoAllocMap
	ref32c01ffc.ConvertedPixelFormat, cConvertedPixelFormat_allocs = (C.int)(x.ConvertedPixelFormat), cgoAllocsUnknown
	allocs32c01ffc.Borrow(cConvertedPixelFormat_allocs)

	var cKeyFrame_allocs *cgoAllocMap
	ref32c01ffc.KeyFrame, cKeyFrame_allocs = (C.int)(x.KeyFrame), cgoAllocsUnknown
	allocs32c01ffc.Borrow(cKeyFrame_allocs)

	var cRepeatPict_allocs *cgoAllocMap
	ref32c01ffc.RepeatPict, cRepeatPict_allocs = (C.int)(x.RepeatPict), cgoAllocsUnknown
	allocs32c01ffc.Borrow(cRepeatPict_allocs)

	var cInterlacedFrame_allocs *cgoAllocMap
	ref32c01ffc.InterlacedFrame, cInterlacedFrame_allocs = (C.int)(x.InterlacedFrame), cgoAllocsUnknown
	allocs32c01ffc.Borrow(cInterlacedFrame_allocs)

	var cTopFieldFirst_allocs *cgoAllocMap
	ref32c01ffc.TopFieldFirst, cTopFieldFirst_allocs = (C.int)(x.TopFieldFirst), cgoAllocsUnknown
	allocs32c01ffc.Borrow(cTopFieldFirst_allocs)

	var cPictType_allocs *cgoAllocMap
	ref32c01ffc.PictType, cPictType_allocs = (C.char)(x.PictType), cgoAllocsUnknown
	allocs32c01ffc.Borrow(cPictType_allocs)

	var cColorSpace_allocs *cgoAllocMap
	ref32c01ffc.ColorSpace, cColorSpace_allocs = (C.int)(x.ColorSpace), cgoAllocsUnknown
	allocs32c01ffc.Borrow(cColorSpace_allocs)

	var cColorRange_allocs *cgoAllocMap
	ref32c01ffc.ColorRange, cColorRange_allocs = (C.int)(x.ColorRange), cgoAllocsUnknown
	allocs32c01ffc.Borrow(cColorRange_allocs)

	var cColorPrimaries_allocs *cgoAllocMap
	ref32c01ffc.ColorPrimaries, cColorPrimaries_allocs = (C.int)(x.ColorPrimaries), cgoAllocsUnknown
	allocs32c01ffc.Borrow(cColorPrimaries_allocs)

	var cTransferCharateristics_allocs *cgoAllocMap
	ref32c01ffc.TransferCharateristics, cTransferCharateristics_allocs = (C.int)(x.TransferCharateristics), cgoAllocsUnknown
	allocs32c01ffc.Borrow(cTransferCharateristics_allocs)

	var cChromaLocation_allocs *cgoAllocMap
	ref32c01ffc.ChromaLocation, cChromaLocation_allocs = (C.int)(x.ChromaLocation), cgoAllocsUnknown
	allocs32c01ffc.Borrow(cChromaLocation_allocs)

	var cHasMasteringDisplayPrimaries_allocs *cgoAllocMap
	ref32c01ffc.HasMasteringDisplayPrimaries, cHasMasteringDisplayPrimaries_allocs = (C.int)(x.HasMasteringDisplayPrimaries), cgoAllocsUnknown
	allocs32c01ffc.Borrow(cHasMasteringDisplayPrimaries_allocs)

	var cMasteringDisplayPrimariesX_allocs *cgoAllocMap
	ref32c01ffc.MasteringDisplayPrimariesX, cMasteringDisplayPrimariesX_allocs = *(*[3]C.double)(unsafe.Pointer(&x.MasteringDisplayPrimariesX)), cgoAllocsUnknown
	allocs32c01ffc.Borrow(cMasteringDisplayPrimariesX_allocs)

	var cMasteringDisplayPrimariesY_allocs *cgoAllocMap
	ref32c01ffc.MasteringDisplayPrimariesY, cMasteringDisplayPrimariesY_allocs = *(*[3]C.double)(unsafe.Pointer(&x.MasteringDisplayPrimariesY)), cgoAllocsUnknown
	allocs32c01ffc.Borrow(cMasteringDisplayPrimariesY_allocs)

	var cMasteringDisplayWhitePointX_allocs *cgoAllocMap
	ref32c01ffc.MasteringDisplayWhitePointX, cMasteringDisplayWhitePointX_allocs = (C.double)(x.MasteringDisplayWhitePointX), cgoAllocsUnknown
	allocs32c01ffc.Borrow(cMasteringDisplayWhitePointX_allocs)

	var cMasteringDisplayWhitePointY_allocs *cgoAllocMap
	ref32c01ffc.MasteringDisplayWhitePointY, cMasteringDisplayWhitePointY_allocs = (C.double)(x.MasteringDisplayWhitePointY), cgoAllocsUnknown
	allocs32c01ffc.Borrow(cMasteringDisplayWhitePointY_allocs)

	var cHasMasteringDisplayLuminance_allocs *cgoAllocMap
	ref32c01ffc.HasMasteringDisplayLuminance, cHasMasteringDisplayLuminance_allocs = (C.int)(x.HasMasteringDisplayLuminance), cgoAllocsUnknown
	allocs32c01ffc.Borrow(cHasMasteringDisplayLuminance_allocs)

	var cMasteringDisplayMinLuminance_allocs *cgoAllocMap
	ref32c01ffc.MasteringDisplayMinLuminance, cMasteringDisplayMinLuminance_allocs = (C.double)(x.MasteringDisplayMinLuminance), cgoAllocsUnknown
	allocs32c01ffc.Borrow(cMasteringDisplayMinLuminance_allocs)

	var cMasteringDisplayMaxLuminance_allocs *cgoAllocMap
	ref32c01ffc.MasteringDisplayMaxLuminance, cMasteringDisplayMaxLuminance_allocs = (C.double)(x.MasteringDisplayMaxLuminance), cgoAllocsUnknown
	allocs32c01ffc.Borrow(cMasteringDisplayMaxLuminance_allocs)

	var cHasContentLightLevel_allocs *cgoAllocMap
	ref32c01ffc.HasContentLightLevel, cHasContentLightLevel_allocs = (C.int)(x.HasContentLightLevel), cgoAllocsUnknown
	allocs32c01ffc.Borrow(cHasContentLightLevel_allocs)

	var cContentLightLevelMax_allocs *cgoAllocMap
	ref32c01ffc.ContentLightLevelMax, cContentLightLevelMax_allocs = (C.uint)(x.ContentLightLevelMax), cgoAllocsUnknown
	allocs32c01ffc.Borrow(cContentLightLevelMax_allocs)

	var cContentLightLevelAverage_allocs *cgoAllocMap
	ref32c01ffc.ContentLightLevelAverage, cContentLightLevelAverage_allocs = (C.uint)(x.ContentLightLevelAverage), cgoAllocsUnknown
	allocs32c01ffc.Borrow(cContentLightLevelAverage_allocs)

	var cDolbyVisionRPU_allocs *cgoAllocMap
	ref32c01ffc.DolbyVisionRPU, cDolbyVisionRPU_allocs = copyPUint8TBytes((*sliceHeader)(unsafe.Pointer(&x.DolbyVisionRPU)))
	allocs32c01ffc.Borrow(cDolbyVisionRPU_allocs)

	var cDolbyVisionRPUSize_allocs *cgoAllocMap
	ref32c01ffc.DolbyVisionRPUSize, cDolbyVisionRPUSize_allocs = (C.int)(x.DolbyVisionRPUSize), cgoAllocsUnknown
	allocs32c01ffc.Borrow(cDolbyVisionRPUSize_allocs)

	var cHDR10Plus_allocs *cgoAllocMap
	ref32c01ffc.HDR10Plus, cHDR10Plus_allocs = copyPUint8TBytes((*sliceHeader)(unsafe.Pointer(&x.HDR10Plus)))
	allocs32c01ffc.Borrow(cHDR10Plus_allocs)

	var cHDR10PlusSize_allocs *cgoAllocMap
	ref32c01ffc.HDR10PlusSize, cHDR10PlusSize_allocs = (C.int)(x.HDR10PlusSize), cgoAllocsUnknown
	allocs32c01ffc.Borrow(cHDR10PlusSize_allocs)

	x.ref32c01ffc = ref32c01ffc
	x.allocs32c01ffc = allocs32c01ffc
	return ref32c01ffc, allocs32c01ffc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Frame) PassValue() (C.FFMS_Frame, *cgoAllocMap) {
	if x.ref32c01ffc != nil {
		return *x.ref32c01ffc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Frame) Deref() {
	if x.ref32c01ffc == nil {
		return
	}
	x.Data = *(*[4]*byte)(unsafe.Pointer(&x.ref32c01ffc.Data))
	x.Linesize = *(*[4]int32)(unsafe.Pointer(&x.ref32c01ffc.Linesize))
	x.EncodedWidth = (int32)(x.ref32c01ffc.EncodedWidth)
	x.EncodedHeight = (int32)(x.ref32c01ffc.EncodedHeight)
	x.EncodedPixelFormat = (int32)(x.ref32c01ffc.EncodedPixelFormat)
	x.ScaledWidth = (int32)(x.ref32c01ffc.ScaledWidth)
	x.ScaledHeight = (int32)(x.ref32c01ffc.ScaledHeight)
	x.ConvertedPixelFormat = (int32)(x.ref32c01ffc.ConvertedPixelFormat)
	x.KeyFrame = (int32)(x.ref32c01ffc.KeyFrame)
	x.RepeatPict = (int32)(x.ref32c01ffc.RepeatPict)
	x.InterlacedFrame = (int32)(x.ref32c01ffc.InterlacedFrame)
	x.TopFieldFirst = (int32)(x.ref32c01ffc.TopFieldFirst)
	x.PictType = (byte)(x.ref32c01ffc.PictType)
	x.ColorSpace = (int32)(x.ref32c01ffc.ColorSpace)
	x.ColorRange = (int32)(x.ref32c01ffc.ColorRange)
	x.ColorPrimaries = (int32)(x.ref32c01ffc.ColorPrimaries)
	x.TransferCharateristics = (int32)(x.ref32c01ffc.TransferCharateristics)
	x.ChromaLocation = (int32)(x.ref32c01ffc.ChromaLocation)
	x.HasMasteringDisplayPrimaries = (int32)(x.ref32c01ffc.HasMasteringDisplayPrimaries)
	x.MasteringDisplayPrimariesX = *(*[3]float64)(unsafe.Pointer(&x.ref32c01ffc.MasteringDisplayPrimariesX))
	x.MasteringDisplayPrimariesY = *(*[3]float64)(unsafe.Pointer(&x.ref32c01ffc.MasteringDisplayPrimariesY))
	x.MasteringDisplayWhitePointX = (float64)(x.ref32c01ffc.MasteringDisplayWhitePointX)
	x.MasteringDisplayWhitePointY = (float64)(x.ref32c01ffc.MasteringDisplayWhitePointY)
	x.HasMasteringDisplayLuminance = (int32)(x.ref32c01ffc.HasMasteringDisplayLuminance)
	x.MasteringDisplayMinLuminance = (float64)(x.ref32c01ffc.MasteringDisplayMinLuminance)
	x.MasteringDisplayMaxLuminance = (float64)(x.ref32c01ffc.MasteringDisplayMaxLuminance)
	x.HasContentLightLevel = (int32)(x.ref32c01ffc.HasContentLightLevel)
	x.ContentLightLevelMax = (uint32)(x.ref32c01ffc.ContentLightLevelMax)
	x.ContentLightLevelAverage = (uint32)(x.ref32c01ffc.ContentLightLevelAverage)
	hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&x.DolbyVisionRPU))
	hxf95e7c8.Data = unsafe.Pointer(x.ref32c01ffc.DolbyVisionRPU)
	hxf95e7c8.Cap = 0x7fffffff
	// hxf95e7c8.Len = ? x.DolbyVisionRPU x.ref32c01ffc.DolbyVisionRPU

	x.DolbyVisionRPUSize = (int32)(x.ref32c01ffc.DolbyVisionRPUSize)
	hxff2234b := (*sliceHeader)(unsafe.Pointer(&x.HDR10Plus))
	hxff2234b.Data = unsafe.Pointer(x.ref32c01ffc.HDR10Plus)
	hxff2234b.Cap = 0x7fffffff
	// hxff2234b.Len = ? x.HDR10Plus x.ref32c01ffc.HDR10Plus

	x.HDR10PlusSize = (int32)(x.ref32c01ffc.HDR10PlusSize)
}

// allocTrackTimeBaseMemory allocates memory for type C.FFMS_TrackTimeBase in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTrackTimeBaseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTrackTimeBaseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTrackTimeBaseValue = unsafe.Sizeof([1]C.FFMS_TrackTimeBase{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TrackTimeBase) Ref() *C.FFMS_TrackTimeBase {
	if x == nil {
		return nil
	}
	return x.refff11a159
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TrackTimeBase) Free() {
	if x != nil && x.allocsff11a159 != nil {
		x.allocsff11a159.(*cgoAllocMap).Free()
		x.refff11a159 = nil
	}
}

// NewTrackTimeBaseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTrackTimeBaseRef(ref unsafe.Pointer) *TrackTimeBase {
	if ref == nil {
		return nil
	}
	obj := new(TrackTimeBase)
	obj.refff11a159 = (*C.FFMS_TrackTimeBase)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TrackTimeBase) PassRef() (*C.FFMS_TrackTimeBase, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refff11a159 != nil {
		return x.refff11a159, nil
	}
	memff11a159 := allocTrackTimeBaseMemory(1)
	refff11a159 := (*C.FFMS_TrackTimeBase)(memff11a159)
	allocsff11a159 := new(cgoAllocMap)
	allocsff11a159.Add(memff11a159)

	var cNum_allocs *cgoAllocMap
	refff11a159.Num, cNum_allocs = (C.int64_t)(x.Num), cgoAllocsUnknown
	allocsff11a159.Borrow(cNum_allocs)

	var cDen_allocs *cgoAllocMap
	refff11a159.Den, cDen_allocs = (C.int64_t)(x.Den), cgoAllocsUnknown
	allocsff11a159.Borrow(cDen_allocs)

	x.refff11a159 = refff11a159
	x.allocsff11a159 = allocsff11a159
	return refff11a159, allocsff11a159

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TrackTimeBase) PassValue() (C.FFMS_TrackTimeBase, *cgoAllocMap) {
	if x.refff11a159 != nil {
		return *x.refff11a159, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TrackTimeBase) Deref() {
	if x.refff11a159 == nil {
		return
	}
	x.Num = (int64)(x.refff11a159.Num)
	x.Den = (int64)(x.refff11a159.Den)
}

// allocFrameInfoMemory allocates memory for type C.FFMS_FrameInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFrameInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFrameInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFrameInfoValue = unsafe.Sizeof([1]C.FFMS_FrameInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FrameInfo) Ref() *C.FFMS_FrameInfo {
	if x == nil {
		return nil
	}
	return x.refb35c55f5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FrameInfo) Free() {
	if x != nil && x.allocsb35c55f5 != nil {
		x.allocsb35c55f5.(*cgoAllocMap).Free()
		x.refb35c55f5 = nil
	}
}

// NewFrameInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFrameInfoRef(ref unsafe.Pointer) *FrameInfo {
	if ref == nil {
		return nil
	}
	obj := new(FrameInfo)
	obj.refb35c55f5 = (*C.FFMS_FrameInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FrameInfo) PassRef() (*C.FFMS_FrameInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb35c55f5 != nil {
		return x.refb35c55f5, nil
	}
	memb35c55f5 := allocFrameInfoMemory(1)
	refb35c55f5 := (*C.FFMS_FrameInfo)(memb35c55f5)
	allocsb35c55f5 := new(cgoAllocMap)
	allocsb35c55f5.Add(memb35c55f5)

	var cPTS_allocs *cgoAllocMap
	refb35c55f5.PTS, cPTS_allocs = (C.int64_t)(x.PTS), cgoAllocsUnknown
	allocsb35c55f5.Borrow(cPTS_allocs)

	var cRepeatPict_allocs *cgoAllocMap
	refb35c55f5.RepeatPict, cRepeatPict_allocs = (C.int)(x.RepeatPict), cgoAllocsUnknown
	allocsb35c55f5.Borrow(cRepeatPict_allocs)

	var cKeyFrame_allocs *cgoAllocMap
	refb35c55f5.KeyFrame, cKeyFrame_allocs = (C.int)(x.KeyFrame), cgoAllocsUnknown
	allocsb35c55f5.Borrow(cKeyFrame_allocs)

	var cOriginalPTS_allocs *cgoAllocMap
	refb35c55f5.OriginalPTS, cOriginalPTS_allocs = (C.int64_t)(x.OriginalPTS), cgoAllocsUnknown
	allocsb35c55f5.Borrow(cOriginalPTS_allocs)

	x.refb35c55f5 = refb35c55f5
	x.allocsb35c55f5 = allocsb35c55f5
	return refb35c55f5, allocsb35c55f5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FrameInfo) PassValue() (C.FFMS_FrameInfo, *cgoAllocMap) {
	if x.refb35c55f5 != nil {
		return *x.refb35c55f5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FrameInfo) Deref() {
	if x.refb35c55f5 == nil {
		return
	}
	x.PTS = (int64)(x.refb35c55f5.PTS)
	x.RepeatPict = (int32)(x.refb35c55f5.RepeatPict)
	x.KeyFrame = (int32)(x.refb35c55f5.KeyFrame)
	x.OriginalPTS = (int64)(x.refb35c55f5.OriginalPTS)
}

// allocVideoPropertiesMemory allocates memory for type C.FFMS_VideoProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVideoPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVideoPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfVideoPropertiesValue = unsafe.Sizeof([1]C.FFMS_VideoProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *VideoProperties) Ref() *C.FFMS_VideoProperties {
	if x == nil {
		return nil
	}
	return x.ref60a9254b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *VideoProperties) Free() {
	if x != nil && x.allocs60a9254b != nil {
		x.allocs60a9254b.(*cgoAllocMap).Free()
		x.ref60a9254b = nil
	}
}

// NewVideoPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVideoPropertiesRef(ref unsafe.Pointer) *VideoProperties {
	if ref == nil {
		return nil
	}
	obj := new(VideoProperties)
	obj.ref60a9254b = (*C.FFMS_VideoProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *VideoProperties) PassRef() (*C.FFMS_VideoProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref60a9254b != nil {
		return x.ref60a9254b, nil
	}
	mem60a9254b := allocVideoPropertiesMemory(1)
	ref60a9254b := (*C.FFMS_VideoProperties)(mem60a9254b)
	allocs60a9254b := new(cgoAllocMap)
	allocs60a9254b.Add(mem60a9254b)

	var cFPSDenominator_allocs *cgoAllocMap
	ref60a9254b.FPSDenominator, cFPSDenominator_allocs = (C.int)(x.FPSDenominator), cgoAllocsUnknown
	allocs60a9254b.Borrow(cFPSDenominator_allocs)

	var cFPSNumerator_allocs *cgoAllocMap
	ref60a9254b.FPSNumerator, cFPSNumerator_allocs = (C.int)(x.FPSNumerator), cgoAllocsUnknown
	allocs60a9254b.Borrow(cFPSNumerator_allocs)

	var cRFFDenominator_allocs *cgoAllocMap
	ref60a9254b.RFFDenominator, cRFFDenominator_allocs = (C.int)(x.RFFDenominator), cgoAllocsUnknown
	allocs60a9254b.Borrow(cRFFDenominator_allocs)

	var cRFFNumerator_allocs *cgoAllocMap
	ref60a9254b.RFFNumerator, cRFFNumerator_allocs = (C.int)(x.RFFNumerator), cgoAllocsUnknown
	allocs60a9254b.Borrow(cRFFNumerator_allocs)

	var cNumFrames_allocs *cgoAllocMap
	ref60a9254b.NumFrames, cNumFrames_allocs = (C.int)(x.NumFrames), cgoAllocsUnknown
	allocs60a9254b.Borrow(cNumFrames_allocs)

	var cSARNum_allocs *cgoAllocMap
	ref60a9254b.SARNum, cSARNum_allocs = (C.int)(x.SARNum), cgoAllocsUnknown
	allocs60a9254b.Borrow(cSARNum_allocs)

	var cSARDen_allocs *cgoAllocMap
	ref60a9254b.SARDen, cSARDen_allocs = (C.int)(x.SARDen), cgoAllocsUnknown
	allocs60a9254b.Borrow(cSARDen_allocs)

	var cCropTop_allocs *cgoAllocMap
	ref60a9254b.CropTop, cCropTop_allocs = (C.int)(x.CropTop), cgoAllocsUnknown
	allocs60a9254b.Borrow(cCropTop_allocs)

	var cCropBottom_allocs *cgoAllocMap
	ref60a9254b.CropBottom, cCropBottom_allocs = (C.int)(x.CropBottom), cgoAllocsUnknown
	allocs60a9254b.Borrow(cCropBottom_allocs)

	var cCropLeft_allocs *cgoAllocMap
	ref60a9254b.CropLeft, cCropLeft_allocs = (C.int)(x.CropLeft), cgoAllocsUnknown
	allocs60a9254b.Borrow(cCropLeft_allocs)

	var cCropRight_allocs *cgoAllocMap
	ref60a9254b.CropRight, cCropRight_allocs = (C.int)(x.CropRight), cgoAllocsUnknown
	allocs60a9254b.Borrow(cCropRight_allocs)

	var cTopFieldFirst_allocs *cgoAllocMap
	ref60a9254b.TopFieldFirst, cTopFieldFirst_allocs = (C.int)(x.TopFieldFirst), cgoAllocsUnknown
	allocs60a9254b.Borrow(cTopFieldFirst_allocs)

	var cColorSpace_allocs *cgoAllocMap
	ref60a9254b.ColorSpace, cColorSpace_allocs = (C.int)(x.ColorSpace), cgoAllocsUnknown
	allocs60a9254b.Borrow(cColorSpace_allocs)

	var cColorRange_allocs *cgoAllocMap
	ref60a9254b.ColorRange, cColorRange_allocs = (C.int)(x.ColorRange), cgoAllocsUnknown
	allocs60a9254b.Borrow(cColorRange_allocs)

	var cFirstTime_allocs *cgoAllocMap
	ref60a9254b.FirstTime, cFirstTime_allocs = (C.double)(x.FirstTime), cgoAllocsUnknown
	allocs60a9254b.Borrow(cFirstTime_allocs)

	var cLastTime_allocs *cgoAllocMap
	ref60a9254b.LastTime, cLastTime_allocs = (C.double)(x.LastTime), cgoAllocsUnknown
	allocs60a9254b.Borrow(cLastTime_allocs)

	var cRotation_allocs *cgoAllocMap
	ref60a9254b.Rotation, cRotation_allocs = (C.int)(x.Rotation), cgoAllocsUnknown
	allocs60a9254b.Borrow(cRotation_allocs)

	var cStereo3DType_allocs *cgoAllocMap
	ref60a9254b.Stereo3DType, cStereo3DType_allocs = (C.int)(x.Stereo3DType), cgoAllocsUnknown
	allocs60a9254b.Borrow(cStereo3DType_allocs)

	var cStereo3DFlags_allocs *cgoAllocMap
	ref60a9254b.Stereo3DFlags, cStereo3DFlags_allocs = (C.int)(x.Stereo3DFlags), cgoAllocsUnknown
	allocs60a9254b.Borrow(cStereo3DFlags_allocs)

	var cLastEndTime_allocs *cgoAllocMap
	ref60a9254b.LastEndTime, cLastEndTime_allocs = (C.double)(x.LastEndTime), cgoAllocsUnknown
	allocs60a9254b.Borrow(cLastEndTime_allocs)

	var cHasMasteringDisplayPrimaries_allocs *cgoAllocMap
	ref60a9254b.HasMasteringDisplayPrimaries, cHasMasteringDisplayPrimaries_allocs = (C.int)(x.HasMasteringDisplayPrimaries), cgoAllocsUnknown
	allocs60a9254b.Borrow(cHasMasteringDisplayPrimaries_allocs)

	var cMasteringDisplayPrimariesX_allocs *cgoAllocMap
	ref60a9254b.MasteringDisplayPrimariesX, cMasteringDisplayPrimariesX_allocs = *(*[3]C.double)(unsafe.Pointer(&x.MasteringDisplayPrimariesX)), cgoAllocsUnknown
	allocs60a9254b.Borrow(cMasteringDisplayPrimariesX_allocs)

	var cMasteringDisplayPrimariesY_allocs *cgoAllocMap
	ref60a9254b.MasteringDisplayPrimariesY, cMasteringDisplayPrimariesY_allocs = *(*[3]C.double)(unsafe.Pointer(&x.MasteringDisplayPrimariesY)), cgoAllocsUnknown
	allocs60a9254b.Borrow(cMasteringDisplayPrimariesY_allocs)

	var cMasteringDisplayWhitePointX_allocs *cgoAllocMap
	ref60a9254b.MasteringDisplayWhitePointX, cMasteringDisplayWhitePointX_allocs = (C.double)(x.MasteringDisplayWhitePointX), cgoAllocsUnknown
	allocs60a9254b.Borrow(cMasteringDisplayWhitePointX_allocs)

	var cMasteringDisplayWhitePointY_allocs *cgoAllocMap
	ref60a9254b.MasteringDisplayWhitePointY, cMasteringDisplayWhitePointY_allocs = (C.double)(x.MasteringDisplayWhitePointY), cgoAllocsUnknown
	allocs60a9254b.Borrow(cMasteringDisplayWhitePointY_allocs)

	var cHasMasteringDisplayLuminance_allocs *cgoAllocMap
	ref60a9254b.HasMasteringDisplayLuminance, cHasMasteringDisplayLuminance_allocs = (C.int)(x.HasMasteringDisplayLuminance), cgoAllocsUnknown
	allocs60a9254b.Borrow(cHasMasteringDisplayLuminance_allocs)

	var cMasteringDisplayMinLuminance_allocs *cgoAllocMap
	ref60a9254b.MasteringDisplayMinLuminance, cMasteringDisplayMinLuminance_allocs = (C.double)(x.MasteringDisplayMinLuminance), cgoAllocsUnknown
	allocs60a9254b.Borrow(cMasteringDisplayMinLuminance_allocs)

	var cMasteringDisplayMaxLuminance_allocs *cgoAllocMap
	ref60a9254b.MasteringDisplayMaxLuminance, cMasteringDisplayMaxLuminance_allocs = (C.double)(x.MasteringDisplayMaxLuminance), cgoAllocsUnknown
	allocs60a9254b.Borrow(cMasteringDisplayMaxLuminance_allocs)

	var cHasContentLightLevel_allocs *cgoAllocMap
	ref60a9254b.HasContentLightLevel, cHasContentLightLevel_allocs = (C.int)(x.HasContentLightLevel), cgoAllocsUnknown
	allocs60a9254b.Borrow(cHasContentLightLevel_allocs)

	var cContentLightLevelMax_allocs *cgoAllocMap
	ref60a9254b.ContentLightLevelMax, cContentLightLevelMax_allocs = (C.uint)(x.ContentLightLevelMax), cgoAllocsUnknown
	allocs60a9254b.Borrow(cContentLightLevelMax_allocs)

	var cContentLightLevelAverage_allocs *cgoAllocMap
	ref60a9254b.ContentLightLevelAverage, cContentLightLevelAverage_allocs = (C.uint)(x.ContentLightLevelAverage), cgoAllocsUnknown
	allocs60a9254b.Borrow(cContentLightLevelAverage_allocs)

	var cFlip_allocs *cgoAllocMap
	ref60a9254b.Flip, cFlip_allocs = (C.int)(x.Flip), cgoAllocsUnknown
	allocs60a9254b.Borrow(cFlip_allocs)

	x.ref60a9254b = ref60a9254b
	x.allocs60a9254b = allocs60a9254b
	return ref60a9254b, allocs60a9254b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x VideoProperties) PassValue() (C.FFMS_VideoProperties, *cgoAllocMap) {
	if x.ref60a9254b != nil {
		return *x.ref60a9254b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *VideoProperties) Deref() {
	if x.ref60a9254b == nil {
		return
	}
	x.FPSDenominator = (int32)(x.ref60a9254b.FPSDenominator)
	x.FPSNumerator = (int32)(x.ref60a9254b.FPSNumerator)
	x.RFFDenominator = (int32)(x.ref60a9254b.RFFDenominator)
	x.RFFNumerator = (int32)(x.ref60a9254b.RFFNumerator)
	x.NumFrames = (int32)(x.ref60a9254b.NumFrames)
	x.SARNum = (int32)(x.ref60a9254b.SARNum)
	x.SARDen = (int32)(x.ref60a9254b.SARDen)
	x.CropTop = (int32)(x.ref60a9254b.CropTop)
	x.CropBottom = (int32)(x.ref60a9254b.CropBottom)
	x.CropLeft = (int32)(x.ref60a9254b.CropLeft)
	x.CropRight = (int32)(x.ref60a9254b.CropRight)
	x.TopFieldFirst = (int32)(x.ref60a9254b.TopFieldFirst)
	x.ColorSpace = (int32)(x.ref60a9254b.ColorSpace)
	x.ColorRange = (int32)(x.ref60a9254b.ColorRange)
	x.FirstTime = (float64)(x.ref60a9254b.FirstTime)
	x.LastTime = (float64)(x.ref60a9254b.LastTime)
	x.Rotation = (int32)(x.ref60a9254b.Rotation)
	x.Stereo3DType = (int32)(x.ref60a9254b.Stereo3DType)
	x.Stereo3DFlags = (int32)(x.ref60a9254b.Stereo3DFlags)
	x.LastEndTime = (float64)(x.ref60a9254b.LastEndTime)
	x.HasMasteringDisplayPrimaries = (int32)(x.ref60a9254b.HasMasteringDisplayPrimaries)
	x.MasteringDisplayPrimariesX = *(*[3]float64)(unsafe.Pointer(&x.ref60a9254b.MasteringDisplayPrimariesX))
	x.MasteringDisplayPrimariesY = *(*[3]float64)(unsafe.Pointer(&x.ref60a9254b.MasteringDisplayPrimariesY))
	x.MasteringDisplayWhitePointX = (float64)(x.ref60a9254b.MasteringDisplayWhitePointX)
	x.MasteringDisplayWhitePointY = (float64)(x.ref60a9254b.MasteringDisplayWhitePointY)
	x.HasMasteringDisplayLuminance = (int32)(x.ref60a9254b.HasMasteringDisplayLuminance)
	x.MasteringDisplayMinLuminance = (float64)(x.ref60a9254b.MasteringDisplayMinLuminance)
	x.MasteringDisplayMaxLuminance = (float64)(x.ref60a9254b.MasteringDisplayMaxLuminance)
	x.HasContentLightLevel = (int32)(x.ref60a9254b.HasContentLightLevel)
	x.ContentLightLevelMax = (uint32)(x.ref60a9254b.ContentLightLevelMax)
	x.ContentLightLevelAverage = (uint32)(x.ref60a9254b.ContentLightLevelAverage)
	x.Flip = (int32)(x.ref60a9254b.Flip)
}

// allocAudioPropertiesMemory allocates memory for type C.FFMS_AudioProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAudioPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAudioPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAudioPropertiesValue = unsafe.Sizeof([1]C.FFMS_AudioProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AudioProperties) Ref() *C.FFMS_AudioProperties {
	if x == nil {
		return nil
	}
	return x.reff68755de
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AudioProperties) Free() {
	if x != nil && x.allocsf68755de != nil {
		x.allocsf68755de.(*cgoAllocMap).Free()
		x.reff68755de = nil
	}
}

// NewAudioPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAudioPropertiesRef(ref unsafe.Pointer) *AudioProperties {
	if ref == nil {
		return nil
	}
	obj := new(AudioProperties)
	obj.reff68755de = (*C.FFMS_AudioProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AudioProperties) PassRef() (*C.FFMS_AudioProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff68755de != nil {
		return x.reff68755de, nil
	}
	memf68755de := allocAudioPropertiesMemory(1)
	reff68755de := (*C.FFMS_AudioProperties)(memf68755de)
	allocsf68755de := new(cgoAllocMap)
	allocsf68755de.Add(memf68755de)

	var cSampleFormat_allocs *cgoAllocMap
	reff68755de.SampleFormat, cSampleFormat_allocs = (C.int)(x.SampleFormat), cgoAllocsUnknown
	allocsf68755de.Borrow(cSampleFormat_allocs)

	var cSampleRate_allocs *cgoAllocMap
	reff68755de.SampleRate, cSampleRate_allocs = (C.int)(x.SampleRate), cgoAllocsUnknown
	allocsf68755de.Borrow(cSampleRate_allocs)

	var cBitsPerSample_allocs *cgoAllocMap
	reff68755de.BitsPerSample, cBitsPerSample_allocs = (C.int)(x.BitsPerSample), cgoAllocsUnknown
	allocsf68755de.Borrow(cBitsPerSample_allocs)

	var cChannels_allocs *cgoAllocMap
	reff68755de.Channels, cChannels_allocs = (C.int)(x.Channels), cgoAllocsUnknown
	allocsf68755de.Borrow(cChannels_allocs)

	var cChannelLayout_allocs *cgoAllocMap
	reff68755de.ChannelLayout, cChannelLayout_allocs = (C.int64_t)(x.ChannelLayout), cgoAllocsUnknown
	allocsf68755de.Borrow(cChannelLayout_allocs)

	var cNumSamples_allocs *cgoAllocMap
	reff68755de.NumSamples, cNumSamples_allocs = (C.int64_t)(x.NumSamples), cgoAllocsUnknown
	allocsf68755de.Borrow(cNumSamples_allocs)

	var cFirstTime_allocs *cgoAllocMap
	reff68755de.FirstTime, cFirstTime_allocs = (C.double)(x.FirstTime), cgoAllocsUnknown
	allocsf68755de.Borrow(cFirstTime_allocs)

	var cLastTime_allocs *cgoAllocMap
	reff68755de.LastTime, cLastTime_allocs = (C.double)(x.LastTime), cgoAllocsUnknown
	allocsf68755de.Borrow(cLastTime_allocs)

	var cLastEndTime_allocs *cgoAllocMap
	reff68755de.LastEndTime, cLastEndTime_allocs = (C.double)(x.LastEndTime), cgoAllocsUnknown
	allocsf68755de.Borrow(cLastEndTime_allocs)

	x.reff68755de = reff68755de
	x.allocsf68755de = allocsf68755de
	return reff68755de, allocsf68755de

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AudioProperties) PassValue() (C.FFMS_AudioProperties, *cgoAllocMap) {
	if x.reff68755de != nil {
		return *x.reff68755de, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AudioProperties) Deref() {
	if x.reff68755de == nil {
		return
	}
	x.SampleFormat = (int32)(x.reff68755de.SampleFormat)
	x.SampleRate = (int32)(x.reff68755de.SampleRate)
	x.BitsPerSample = (int32)(x.reff68755de.BitsPerSample)
	x.Channels = (int32)(x.reff68755de.Channels)
	x.ChannelLayout = (int64)(x.reff68755de.ChannelLayout)
	x.NumSamples = (int64)(x.reff68755de.NumSamples)
	x.FirstTime = (float64)(x.reff68755de.FirstTime)
	x.LastTime = (float64)(x.reff68755de.LastTime)
	x.LastEndTime = (float64)(x.reff68755de.LastEndTime)
}

// allocKeyValuePairMemory allocates memory for type C.FFMS_KeyValuePair in C.
// The caller is responsible for freeing the this memory via C.free.
func allocKeyValuePairMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfKeyValuePairValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfKeyValuePairValue = unsafe.Sizeof([1]C.FFMS_KeyValuePair{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *KeyValuePair) Ref() *C.FFMS_KeyValuePair {
	if x == nil {
		return nil
	}
	return x.refb4378ab6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *KeyValuePair) Free() {
	if x != nil && x.allocsb4378ab6 != nil {
		x.allocsb4378ab6.(*cgoAllocMap).Free()
		x.refb4378ab6 = nil
	}
}

// NewKeyValuePairRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewKeyValuePairRef(ref unsafe.Pointer) *KeyValuePair {
	if ref == nil {
		return nil
	}
	obj := new(KeyValuePair)
	obj.refb4378ab6 = (*C.FFMS_KeyValuePair)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *KeyValuePair) PassRef() (*C.FFMS_KeyValuePair, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb4378ab6 != nil {
		return x.refb4378ab6, nil
	}
	memb4378ab6 := allocKeyValuePairMemory(1)
	refb4378ab6 := (*C.FFMS_KeyValuePair)(memb4378ab6)
	allocsb4378ab6 := new(cgoAllocMap)
	allocsb4378ab6.Add(memb4378ab6)

	var cKey_allocs *cgoAllocMap
	refb4378ab6.Key, cKey_allocs = copyPCharBytes((*sliceHeader)(unsafe.Pointer(&x.Key)))
	allocsb4378ab6.Borrow(cKey_allocs)

	var cValue_allocs *cgoAllocMap
	refb4378ab6.Value, cValue_allocs = copyPCharBytes((*sliceHeader)(unsafe.Pointer(&x.Value)))
	allocsb4378ab6.Borrow(cValue_allocs)

	x.refb4378ab6 = refb4378ab6
	x.allocsb4378ab6 = allocsb4378ab6
	return refb4378ab6, allocsb4378ab6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x KeyValuePair) PassValue() (C.FFMS_KeyValuePair, *cgoAllocMap) {
	if x.refb4378ab6 != nil {
		return *x.refb4378ab6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *KeyValuePair) Deref() {
	if x.refb4378ab6 == nil {
		return
	}
	hxff73280 := (*sliceHeader)(unsafe.Pointer(&x.Key))
	hxff73280.Data = unsafe.Pointer(x.refb4378ab6.Key)
	hxff73280.Cap = 0x7fffffff
	// hxff73280.Len = ? x.Key x.refb4378ab6.Key

	hxfa9955c := (*sliceHeader)(unsafe.Pointer(&x.Value))
	hxfa9955c.Data = unsafe.Pointer(x.refb4378ab6.Value)
	hxfa9955c.Cap = 0x7fffffff
	// hxfa9955c.Len = ? x.Value x.refb4378ab6.Value

}

func (x TIndexCallback) PassRef() (ref *C.TIndexCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tIndexCallback6D729B4EFunc == nil {
		tIndexCallback6D729B4EFunc = x
	}
	return (*C.TIndexCallback)(C.TIndexCallback_6d729b4e), nil
}

func (x TIndexCallback) PassValue() (ref C.TIndexCallback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tIndexCallback6D729B4EFunc == nil {
		tIndexCallback6D729B4EFunc = x
	}
	return (C.TIndexCallback)(C.TIndexCallback_6d729b4e), nil
}

func NewTIndexCallbackRef(ref unsafe.Pointer) *TIndexCallback {
	return (*TIndexCallback)(ref)
}

//export tIndexCallback6D729B4E
func tIndexCallback6D729B4E(ccurrent C.int64_t, ctotal C.int64_t, ciCPrivate unsafe.Pointer) C.int {
	if tIndexCallback6D729B4EFunc != nil {
		current6d729b4e := (int64)(ccurrent)
		total6d729b4e := (int64)(ctotal)
		iCPrivate6d729b4e := (unsafe.Pointer)(unsafe.Pointer(ciCPrivate))
		ret6d729b4e := tIndexCallback6D729B4EFunc(current6d729b4e, total6d729b4e, iCPrivate6d729b4e)
		ret, _ := (C.int)(ret6d729b4e), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var tIndexCallback6D729B4EFunc TIndexCallback

// unpackPCharString copies the data from Go string as *C.char.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CString(str))
	allocs.Add(mem0)
	return (*C.char)(mem0), allocs
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// copyPIndexBytes copies the data from Go slice as *C.FFMS_Index.
func copyPIndexBytes(slice *sliceHeader) (*C.FFMS_Index, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfIndexValue) * slice.Len,
		Cap:  int(sizeOfIndexValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.FFMS_Index)(mem0), allocs
}

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackArgSErrorInfo transforms a sliced Go data structure into plain C format.
func unpackArgSErrorInfo(x []ErrorInfo) (unpacked *C.FFMS_ErrorInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocErrorInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.FFMS_ErrorInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.FFMS_ErrorInfo)(h.Data)
	return
}

// packSErrorInfo reads sliced Go data structure out from plain C format.
func packSErrorInfo(v []ErrorInfo, ptr0 *C.FFMS_ErrorInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfErrorInfoValue]C.FFMS_ErrorInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewErrorInfoRef(unsafe.Pointer(&ptr1))
	}
}

// copyPVideoSourceBytes copies the data from Go slice as *C.FFMS_VideoSource.
func copyPVideoSourceBytes(slice *sliceHeader) (*C.FFMS_VideoSource, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfVideoSourceValue) * slice.Len,
		Cap:  int(sizeOfVideoSourceValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.FFMS_VideoSource)(mem0), allocs
}

// copyPAudioSourceBytes copies the data from Go slice as *C.FFMS_AudioSource.
func copyPAudioSourceBytes(slice *sliceHeader) (*C.FFMS_AudioSource, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfAudioSourceValue) * slice.Len,
		Cap:  int(sizeOfAudioSourceValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.FFMS_AudioSource)(mem0), allocs
}

// copyPIntBytes copies the data from Go slice as *C.int.
func copyPIntBytes(slice *sliceHeader) (*C.int, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfIntValue) * slice.Len,
		Cap:  int(sizeOfIntValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.int)(mem0), allocs
}

// allocIntMemory allocates memory for type C.int in C.
// The caller is responsible for freeing the this memory via C.free.
func allocIntMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfIntValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfIntValue = unsafe.Sizeof([1]C.int{})

// unpackArgSResampleOptions transforms a sliced Go data structure into plain C format.
func unpackArgSResampleOptions(x []ResampleOptions) (unpacked *C.FFMS_ResampleOptions, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocResampleOptionsMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.FFMS_ResampleOptions)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.FFMS_ResampleOptions)(h.Data)
	return
}

// packSResampleOptions reads sliced Go data structure out from plain C format.
func packSResampleOptions(v []ResampleOptions, ptr0 *C.FFMS_ResampleOptions) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfResampleOptionsValue]C.FFMS_ResampleOptions)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewResampleOptionsRef(unsafe.Pointer(&ptr1))
	}
}

// copyPIndexerBytes copies the data from Go slice as *C.FFMS_Indexer.
func copyPIndexerBytes(slice *sliceHeader) (*C.FFMS_Indexer, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfIndexerValue) * slice.Len,
		Cap:  int(sizeOfIndexerValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.FFMS_Indexer)(mem0), allocs
}

// copyPTrackBytes copies the data from Go slice as *C.FFMS_Track.
func copyPTrackBytes(slice *sliceHeader) (*C.FFMS_Track, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTrackValue) * slice.Len,
		Cap:  int(sizeOfTrackValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.FFMS_Track)(mem0), allocs
}

// unpackArgSKeyValuePair transforms a sliced Go data structure into plain C format.
func unpackArgSKeyValuePair(x []KeyValuePair) (unpacked *C.FFMS_KeyValuePair, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocKeyValuePairMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.FFMS_KeyValuePair)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.FFMS_KeyValuePair)(h.Data)
	return
}

// packSKeyValuePair reads sliced Go data structure out from plain C format.
func packSKeyValuePair(v []KeyValuePair, ptr0 *C.FFMS_KeyValuePair) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfKeyValuePairValue]C.FFMS_KeyValuePair)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewKeyValuePairRef(unsafe.Pointer(&ptr1))
	}
}

// allocPUint8TMemory allocates memory for type *C.uint8_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPUint8TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPUint8TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPUint8TValue = unsafe.Sizeof([1]*C.uint8_t{})

// unpackArgSSByte transforms a sliced Go data structure into plain C format.
func unpackArgSSByte(x [][]byte) (unpacked **C.uint8_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPUint8TMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.uint8_t)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.uint8_t)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.uint8_t)(h.Data)
	return
}

// packSSByte reads sliced Go data structure out from plain C format.
func packSSByte(v [][]byte, ptr0 **C.uint8_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.uint8_t)(unsafe.Pointer(ptr0)))[i0]
		hxfa3f05c := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxfa3f05c.Data = unsafe.Pointer(ptr1)
		hxfa3f05c.Cap = 0x7fffffff
		// hxfa3f05c.Len = ?
	}
}

// copyPSizeTBytes copies the data from Go slice as *C.size_t.
func copyPSizeTBytes(slice *sliceHeader) (*C.size_t, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfSizeTValue) * slice.Len,
		Cap:  int(sizeOfSizeTValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.size_t)(mem0), allocs
}

// allocSizeTMemory allocates memory for type C.size_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSizeTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSizeTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSizeTValue = unsafe.Sizeof([1]C.size_t{})
